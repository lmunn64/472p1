package edu.iastate.cs472.proj1;

import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.Scanner;
import java.io.File;

/**
 *  
 * @author
 *
 */


/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board; 		// configuration of tiles 
	
	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state
    public int[] empty = {0,0}; // location of empty square
	public static Heuristic heu; // heuristic used. shared by all the states. 
	
	private int numMismatchedTiles = -1;    // number of mismatched tiles between this state 
	                                        // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;     // Manhattan distance between this state and the 
	                                        // goal state; negative if not computed yet. 
	private int numSingleDoubleMoves = -1;  // number of single and double moves with each double 
										    // move counted as one; negative if not computed yet. 
    static final int[][] GOALSTATE = {{1,2,3},{8,0,4},{7,6,5}};
	
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException 
    {
    	this.board = board;
        for(int i = 0; i < 3; i++){
			for(int j = 0; j < 3; j++){
				if((board[i][j] == 0)){
                    empty[0] = i;
                    empty[1] = j;
                }
			}
		}
        previous = null;
        next = null;
        predecessor = null;
        move = null;
        numMoves = 0;
	}
    
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException
    {
        int[][] initBoard = new int[3][3];
        File file = new File("8Puzzle.txt");
        Scanner scnr = new Scanner(file);
		int j = 0;
		int i = 0;
		while(scnr.hasNext()){
			initBoard[i][j] = Integer.valueOf(scnr.next());
			switch((j + 1) % 3){
				case 0:
					i++;
					j=0;
					break;
				default:
					j++;
					break;
			}
		}

    	this.board = initBoard;
        previous = null;
        next = null;
        predecessor = null;
        move = null;
        numMoves = 0;

        // for(i = 0; i < 3; i++){
		// 	for(j = 0; j < 3; j++){
		// 		System.out.print(board[i][j]  + " ");
		// 	}
		// 	System.out.println();
		// }
	}
    
    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Set the variable numMoves for the successor state to this.numMoves + 1. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, DOWN, DBL_LEFT, DBL_RIGHT, DBL_UP, and DBL_DOWN
     * @return null  			if the successor state is this.predecessor
     *         successor state  otherwise 
     * @throws IllegalArgumentException if LEFT when the empty square is in the right column, or  
     *                                  if RIGHT when the empty square is in the left column, or
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row, or
     *                                  if DBL_LEFT when the empty square is not in the left column, or 
     *                                  if DBL_RIGHT when the empty square is not in the right column, or 
     *                                  if DBL_UP when the empty square is not in the top row, or 
     *                                  if DBL_DOWN when the empty square is not in the bottom row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException 
    {
        int i = empty[0];
        int j = empty[1];

        State succ = this.clone();

        // test equals to predecessor
        if(this.equals(succ)){
            return null;
        }
        
        // check and handle move
    	switch(m){
            case LEFT:
                if(j < 2){
                    temp = succ.board[i][j+1];
                    succ.board[i][j] = temp;
                    succ.board[i][j+1] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move LEFT");
                }
                break;
            case RIGHT:
                if(j > 0){
                    temp = succ.board[i][j-1];
                    succ.board[i][j] = temp;
                    succ.board[i][j-1] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move RIGHT");
                }
                break;
            case UP:
                if(i < 2){
                    temp = succ.board[i+1][j];
                    succ.board[i][j] = temp;
                    succ.board[i+1][j] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move UP");
                }
                break;
            case DOWN:
                if(i > 0){
                    temp = succ.board[i-1][j];
                    succ.board[i][j] = temp;
                    succ.board[i-1][j] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move DOWN");
                }
                break;
            case DBL_RIGHT:
                if(j == 2){
                    temp1 = succ.board[i][j-1];
                    temp2 = succ.board[i][j-2];
                    succ.board[i][j] = temp1;
                    succ.board[i][j-1] = temp2;
                    succ.board[i][j-2] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move DBL_RIGHT");
                }
                break;
            case DBL_LEFT:
                if(j == 0){
                    temp1 = succ.board[i][j+1];
                    temp2 = succ.board[i][j+2];
                    succ.board[i][j] = temp1;
                    succ.board[i][j+1] = temp2;
                    succ.board[i][j+2] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move DBL_LEFT");
                }
                break;
            case DBL_UP:
                if(i == 0){
                    temp1 = succ.board[i+1][j];
                    temp2 = succ.board[i+2][j];
                    succ.board[i][j] = temp1;
                    succ.board[i+1][j] = temp2;
                    succ.board[i+2][j] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move DBL_UP");
                }
                break;
            case DBL_DOWN:
                if(i == 2){
                    temp1 = succ.board[i-1][j];
                    temp2 = succ.board[i-2][j];
                    succ.board[i][j] = temp1;
                    succ.board[i-1][j] = temp2;
                    succ.board[i-2][j] = 0;
                }
                else{
                    throw new IllegalArgumentException("Illegal move DBL_DOWN");
                }
                break; 
        }
    	
        succ.predecessor = this;
        succ.move = m;
        succ.numMoves = this.numMoves + 1;

        return succ;  
    }
    
        
    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the PowerPoint notes that introduce the 8-puzzle, we check if this state has an odd number 
     * of inversions. 
     */
    /**
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable()
    {
        int inversions = 0;
    	for(int i = 0; i < 9; i++){
            if(board[i/3][i%3] == 0){
                i++;
            }
			for(int j = i+1; j < 9; j++){
				if((board[j/3][j%3] < board[i/3][i%3]) && (board[j/3][j%3] != 0)){
                    inversions++;
                }
			}
		}
        if((inversions - 7) % 2 == 0){
            return true; 
        }
    	return false;
    }
    
    
    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return
     */
    public boolean isGoalState()
    {
    	if(Arrays.deepEquals(GOALSTATE, board)){
            return true;
        }
    	return false; 
    }
    
    
    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override 
    public String toString(){
    	String hello = "";
        for(int i = 0; i < 3; i++){
			for(int j = 0; j < 3; j++){
				if(board[i][j] == 0){
                    hello = hello + " ";
                }
                else{
                    hello = hello + board[i][j];
                }
                if(j < 2){
                    hello = hello + " ";
                }
                else{
                    hello = hello + "\n";
                }
			}
        }
        return hello;
    }
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone()
    {
        int[][] newBoard;

    	for(int a = 0; a < 3; a++){
			for(int b = 0; b < 3; b++){
				newBoard[a][b] = this.board[a][b];
			}
		}

        State clone = new State(newBoard);
        clone.predecessor = null;
        clone.previous = null;
        clone.next = null;

    	return clone; 
    }
  

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override 
    public boolean equals(Object o)
    {
    	if (Arrays.deepEquals(board, o.board)){
            return true; 
        }
    	return false;
    }
        
    
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
     * If heu == DoubleMoveHeuristic, add up numMoves and the return value of computeNumSingleDoubleMoves(). 
     * 
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is none of TileMismatch, MahattanDist, DoubleMoveHeuristic. 
     */
    public int cost() throws IllegalArgumentException
    {
    	//TODO 
    	return 0; 
    }

    
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s)
    {
    	// TODO 
    	return 0; 
    }
    

    /**
     * Return the value of the private variable numMismatchedTiles if it is non-negative, and compute its 
     * value otherwise. 
     * 
     * @return the number of mismatched tiles between this state and the goal state. 
     */
	public int computeNumMismatchedTiles()
	{
        int mismatched = 0;
        if(numMismatchedTiles > 0){
            return numMismatchedTiles;
        }
		for(int a = 0; a < 3; a++){
			for(int b = 0; b < 3; b++){
				if((GOALSTATE[a][b] != this.board[a][b]) && this.board[a][b] != 0){
                    mismatched++;
                }
			}
		}
		return mismatched; 
	}

	
	/**
	 * Return the value of the private variable ManhattanDistance if it is non-negative, and compute its value 
	 * otherwise.
	 * 
	 * @return the Manhattan distance between this state and the goal state. 
	 */
	public int computeManhattanDistance()
	{
        int dist = 0;
        if(ManhattanDistance > 0){
            return ManhattanDistance;
        }

		for(int i = 0; i < 9; i++){
            if(board[i/3][i%3] == 0){
                i++;
            }
			for(int j = 0; j < 9; j++){
				if(GOALSTATE[j/3][j%3] == board[i/3][i%3]){
                    dist += Math.abs((i/3) - (j/3)) + Math.abs((i%3) - (j%3));
                }
			}
		} 
        ManhattanDistance = dist;
		return dist; 
	}
	
	
	/**
	 * Return the value of the private variable numSingleDoubleMoves if it is non-negative, and compute its value 
	 * otherwise. 
	 * 
	 * @return the value of the private variable numSingleDoubleMoves that bounds from below the number of moves, 
	 *         single or double, which will take this state to the goal state.
	 */
	public int computeNumSingleDoubleMoves()
	{
		int dist = 0;
        if(numSingleDoubleMoves > 0){
            return numSingleDoubleMoves;
        }

		for(int i = 0; i < 3; i++){
			for(int j = 0; j < 3; j++){
                if(i == 1){
                    if(j == 1){
                        if(board[i][j] == 0){
                            continue;
                        }
                        else{
                            if(board[i][j-1] == 0){
                                continue;
                            }
                            else{
                                // DBL_RIGHT MOVE (where both squares belong on top or bottom in goal state after a DBL_RIGHT)
                                if(((board[i][j-1] == GOALSTATE[i-1][j]) || (board[i][j-1] == GOALSTATE[i+1][j])) && ((board[i][j] == GOALSTATE[i+1][j+1]) || (board[i][j] == GOALSTATE[i-1][j+1]))){
                                    dist+=3;
                                } 
                            }
                            if(board[i][j+1] == 0){
                                continue;
                            }
                            else{
                                // DBL_LEFT MOVE (where both squares belong on top or bottom in goal state after a DBL_LEFT)
                                if(((board[i][j+1] == GOALSTATE[i-1][j]) || (board[i][j+1] == GOALSTATE[i+1][j])) && ((board[i][j] == GOALSTATE[i+1][j-1]) || (board[i][j] == GOALSTATE[i-1][j-1]))){
                                    dist+=3;
                                }
                            }
                            if(board[i+1][j] == 0){
                                continue;
                            }
                            else{
                                // DBL_UP MOVE (where both squares belong on top or bottom in goal state after a DBL_UP)
                                if(((board[i+1][j] == GOALSTATE[i][j+1]) || (board[i+1][j] == GOALSTATE[i][j-1])) && ((board[i][j] == GOALSTATE[i-1][j-1]) || (board[i][j] == GOALSTATE[i-1][j+1]))){
                                    dist+=3;
                                }
                            }
                            if(board[i-1][j] == 0){
                                continue;
                            }
                            else{
                                // DBL_DOWN MOVE (where both squares belong on top or bottom in goal state after a DBL_DOWN)
                                if(((board[i-1][j] == GOALSTATE[i][j+1]) || (board[i-1][j] == GOALSTATE[i][j-1])) && ((board[i][j] == GOALSTATE[i+1][j-1]) || (board[i][j] == GOALSTATE[i+1][j+1]))){
                                    dist+=3;
                                }
                            }
                        }
                    }
                    else{
                        if(board[i+1][j] == 0){
                            continue;
                        }
                        else{
                            // DBL_UP MOVE
                            if((board[i+1][j] == GOALSTATE[i][j]) && (board[i][j] == GOALSTATE[i-1][j])){
                                dist+=1;
                            }
                        }
                        if(board[i-1][j] == 0){
                            continue;
                        }
                        else{
                            // DBL_DOWN MOVE
                            if((board[i-1][j] == GOALSTATE[i][j]) && ((board[i][j] == GOALSTATE[i+1][j]))){
                                dist+=1;
                            }
                        }  
                    }
                 }  
                else if(i == 0){
                    if(j == 1){
                        if(board[i][j] == 0 || board[i][j+1] == 0){
                            continue;
                        }
                        else{
                            // DBL_RIGHT 
                            if((board[i][j-1] == GOALSTATE[i][j]) && (board[i][j] == GOALSTATE[i][j+1])){
                                dist++;
                            }
                            //DBL_LEFT
                            if((board[i][j+1] == GOALSTATE[i][j]) && (board[i][j] == GOALSTATE[i][j-1])){
                                dist++;
                            }
                        } 
                    }
                }   
			}
		}  
		return dist; 
	}
}
