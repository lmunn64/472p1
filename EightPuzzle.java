package edu.iastate.cs472.proj1;

import java.io.FileNotFoundException;

/**
 *  
 * @author
 *
 */

public class EightPuzzle 
{
	/**
	 * This static method solves an 8-puzzle with a given initial state using three heuristics. The 
	 * first two, allowing single moves only, compare the board configuration with the goal configuration 
	 * by the number of mismatched tiles, and by the Manhattan distance, respectively.  The third 
	 * heuristic, designed by yourself, allows double moves and must be also admissible.  The goal 
	 * configuration set for all puzzles is
	 * 
	 * 			1 2 3
	 * 			8   4
	 * 			7 6 5
	 * 
	 * @param s0
	 * @return a string specified in the javadoc below
	 */
	public static String solve8Puzzle(State s0)
	{
		// TODO 
		
		// 1) If there exists no solution, return a message that starts with "No solution 
		//    exists for the following initial state:" and follows with a blank line and 
		//    then what would be the output from a call s0.toString(). See the end of 
		//    Section 6 in the project description for an example. 
		if(!s0.solvable()){
			return "No solution exists for the following initial state: \n \n" + s0.toString();
		}

		// 2) Otherwise, solve the puzzle with the three heuristics.  The two solutions generated by
		//    the first two heuristics may be different but must have the same length for optimality. 
		
		Heuristic h[] = {Heuristic.TileMismatch, Heuristic.ManhattanDist, Heuristic.DoubleMoveHeuristic }; 
		String [] moves = new String[3]; 
		String allMoves = "";
		for (int i = 0; i < 3; i++)
		{
			moves[i] = AStar(s0, h[i]); 
			allMoves += moves[i] + "\n";
		}
		
		// 3) Combine the three solution strings into one that would print out in the 
		//    output format specified in Section 6 of the project description.
		
		return allMoves; 
	}

	
	/**
	 * This method implements the A* algorithm to solve the 8-puzzle with an input initial state s0. 
	 * The algorithm implementation is described in Section 3 of the project description. 
	 * 
	 * Precondition: the puzzle is solvable with the initial state s0.
	 * 
	 * @param s0  initial state
	 * @param h   heuristic 
	 * @return    solution string 
	 */
	public static String AStar(State s0, Heuristic h)
	{
		Move[] DBL_MOVES = {Move.DOWN, Move.UP, Move.RIGHT, Move.LEFT, Move.DBL_DOWN, Move.DBL_LEFT, Move.DBL_RIGHT, Move.DBL_UP};
		Move[] BASIC_MOVES = {Move.DOWN, Move.UP, Move.RIGHT, Move.LEFT};
		Move MOVES[] = BASIC_MOVES;
		if(h == Heuristic.DoubleMoveHeuristic){
			MOVES = DBL_MOVES;
		}
		Move Moe = Move.DBL_DOWN;
		// Initialize the two lists used by the algorithm. 
		OrderedStateList OPEN = new OrderedStateList(h, true); 
		OrderedStateList CLOSE = new OrderedStateList(h, false);		
		
		// Implement the algorithm described in Section 3 to solve the puzzle. 
		OPEN.addState(s0);
		s0.numMoves = 0;
		int hs0 = s0.cost();
		State currState = s0;
		while(!currState.isGoalState()){
			currState = OPEN.remove();
			if(OPEN.size() < 1){
				return "Exit Status: FAILURE";
			}
			else{
				CLOSE.addState(currState);
				if(currState.isGoalState()){
				}
				for(Move i : MOVES){
					try {
						State t = currState.successorState(i);
						// if t is not predecessor state
						if(t != null){
							t.cost();
							State OpenState = OPEN.findState(t);
							State CloseState = CLOSE.findState(t);
							if(OpenState != null){
								//new is less
								if (t.compareTo(OpenState) < 0){
									t.predecessor = currState;
								}
							}
							if(CloseState != null){
								//new is less
								if (t.compareTo(CloseState) < 0){
									t.predecessor = currState;
									CLOSE.removeState(t);
									OPEN.addState(t);
								}
							}
							else{
								OPEN.addState(t);
							}
						}
						
					} catch (IllegalArgumentException e) {
						continue;
					}
				}
	
			}
		}
		// Once a goal state s is reached, call solutionPath(s) and return the solution string. 
		return solutionPath(currState);						
	}
	
	
	
	/**
	 * From a goal state, follow the predecessor link to trace all the way back to the initial state. 
	 * Meanwhile, generate a string to represent board configurations in the reverse order, with 
	 * the initial configuration appearing first. Between every two consecutive configurations 
	 * is the move that causes their transition. A blank line separates a move and a configuration.  
	 * In the string, the sequence is preceded by the total number of moves and a blank line. 
	 * 
	 * See Section 6 in the projection description for an example. 
	 * 
	 * Call the toString() method of the State class. 
	 * 
	 * @param goal
	 * @return
	 */
	private static String solutionPath(State goal)
	{
		String result = "";
		String[] arr = new String[goal.numMoves+1];
		int i = 0;
		if(goal.heu == Heuristic.TileMismatch){
			result = goal.numMoves + " moves in total (heuristic: number of mismatched tiles)\n \n";
		}
		if(goal.heu == Heuristic.ManhattanDist){
			result = goal.numMoves + " moves in total (heuristic: the Manhattan Distance)\n \n";
		}
		if(goal.heu == Heuristic.DoubleMoveHeuristic){
			result = goal.numMoves + " moves in total (heuristic: double moves allowed)\n \n";
		}
		while(goal.predecessor != null){
			arr[i] =  goal.move + "\n\n" + goal.toString() + "\n";
			goal = goal.predecessor;
			i++;
		}
		arr[i] =  goal.toString() + "\n";
		for(int j = i; j > -1; j--){
			result+=arr[j];
		}
	
		return result; 
	}
	
	
	
}
